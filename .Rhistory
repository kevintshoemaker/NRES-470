phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
#########
# And another example!
#########
Rmax1 <- 0.5
Alpha <- 1.05
K1 <- 890
Rmax2 <- 0.2
Beta <- 0.5
K2 <- 890
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
########
# And another!
#########
Alpha <- 0.3
Beta <- 0.2
K1 <- 1000
K2 <- 450
Rmax1 <- 0.05
Rmax2 <- 0.3
Nyears <- 1000
ylim=c(0,K2*1.5)
xlim=c(0,K1*1.5)
plot(1,1,pch="",ylim=ylim,xlim=xlim,xlab="species 1",ylab="species 2")
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.4)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.4)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.4)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.4)
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=15,parms=parms)
phasearrows.draw(new)
abline(h=K2,v=K1,col="gray",lwd=2,lty=2)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=2)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=2)   # species 2
########
# And finally...
########
Rmax1 <- 0.2
Alpha <- 1.5
K1 <- 1000
Rmax2 <- 0.2
Beta <- 2
K2 <- 1500
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE16.Rmd',rmarkdown::pdf_document())
rmarkdown::render('FINAL_PROJECTS.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#######
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
unlink('LECTURE17_cache', recursive = TRUE)
######
# Numerical response
LVnumresp <- function(V,beta){
beta*V
}
curve(LVnumresp(x,0.001),0,200,xlab="Victim abundance",ylab="Increase in r for predator population",col="blue",lwd=3)
##### LOTKA VOLTERRA PREDATION EXAMPLE (on phase plane)
## Params
Alpha <- 0.001
Beta <- 0.001
InitPrey <- 100
InitPred <- 75
r <- 0.1
q <- 0.1
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
plot(1,1,pch="",ylim=c(0,200),xlim=c(0,200),xlab="prey",ylab="predators")
points(System[seq(1,1000,10),],col="green",type="p",pch=20,cex=0.85)
points(System[1,],col="blue",pch=20,cex=3)
#######################################################################################
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]-parms[2]*u*v - parms[3]*u^2, parms[4]*u*v-parms[5]*v )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
parms=c(r,Alpha,c,Beta,q)
# toggle(100,100,parms)
xlim = c(5,200)
ylim = c(5,200)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.1,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE17.Rmd',rmarkdown::pdf_document())
rmarkdown::render('EXTRA_CREDIT.Rmd',rmarkdown::pdf_document())
citation('vegan')
citation('jagsUI')
6/8
unlink('LECTURE18_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE18.Rmd',rmarkdown::pdf_document())
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE18.Rmd',rmarkdown::pdf_document())
install.packages("FLightR")
N=numeric(31)
names(N)=0:30
N
N[0]
N["0"]
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
54/3
27*3
46*3
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,15000,10)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 0.9   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00006    # D-D terms
c <- 0.00002
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,15000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
(b-d)/(a+c)
a <- 0.00006    # D-D terms
c <- 0.00002
b <- b_max - a*Density
d <- d_min + c*Density
(b-d)/(a+c)
(b_max-d_min)/(a+c)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table2.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Elephant_age <- seq(0,60,by=2)
Birth_rate <- c(rep(0,times=7),seq(0,0.3,length=4),rep(0.3,times=15),seq(0.3,0,length=5))
names(Birth_rate) <- Elephant_age
barplot(Birth_rate,xlab="Age",ylab="b, per-capita birth rate",col="blue",ylim=c(0,0.5))
Tortoise_age <- seq(0,120,by=5)
Death_rate <- c(seq(0.7,0.05,length=5),seq(0.02,0.02,length=16),seq(0.02,0.5,length=4))
names(Death_rate) <- Tortoise_age
barplot(Death_rate,xlab="Age",ylab="d, per-capita death rate",col="blue")
lifetable <- read.csv("life_table.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table2.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
lifetable <- read.csv("life_table2.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
unlink('LAB3_cache', recursive = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
2*log(5)
log(5^2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('FINAL_PROJECTS.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE7.Rmd',rmarkdown::pdf_document())
unlink('LAB4_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table4.csv")
lifetable
stmat <- read.csv("stage_matrix1.csv")
stmat <- as.matrix(stmat[,-1])
rownames(stmat) <- colnames(stmat)
stmat
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
library(qdapDictionaries)
mydict <- qdapDictionaries::GradyAugmented  #[1:10000]  # clearly not the one used by NYT!
mydict <- mydict[!grepl("'",mydict)]
mydict <- mydict[!grepl("-",mydict)]
mydict <- mydict[nchar(mydict)>3]
today <- c("a","h","t","d","o","i","n")  # first word is center
allowed <- sprintf("[%s]",paste(today,collapse=""))
not_allowed <- sprintf("^[^%s]+$",paste(setdiff(letters,today),collapse=""))
allowed_words <- mydict[grepl(not_allowed,mydict)]
correct_words <- allowed_words[grepl(today[1],allowed_words)]
correct_words
250/4
8125*0.65/4
6*4.5+2*3.3
58+45+_33
58+45+33
136*(85/400)
# age 3
10*(31/40)
# age 4
10*(5/31)
8*4.5+2*3.3
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
stmat <- read.csv("stage_matrix1.csv")
stmat <- as.matrix(stmat[,-1])
rownames(stmat) <- colnames(stmat)
stmat
library(popbio)
lambda(stmat)
stmat
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE9.Rmd',rmarkdown::pdf_document())
sqrt(100/40)
ln(100/40)/2
log(100/40)/2
20/34
28/34
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE9.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
log(1.1)
exp(0.095)
sqrt(2.5)
log(2.5)/2
log(1.58)
log(1.581)
0.65^(1/365)
?sptransform
?spTransform
# lb = .45 and ub is 0.75
lb= .45
ub=0.75
ub-lb
0.45+0.15
0.15/2
curve(dnorm(x,0.6,0.075),0,1)
0.75^3
1-0.421875
0.9^30
4.28/4
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
r <- 0.1     #Assign the value of 0.1 to the object "r", or per-capita growth rate (discrete)
lambda <- 1+r  # define lambda
N0 <- 100    #Assign the value of 100 to the object "N0", or initial population size
nyears <- 30 #Assign the value of 30 to the object "nyears", or the number of time steps to simulate
N0 * lambda   #Multiplies the value stored in the object "N0" by lambda. As soon as you run this line of code, the result of the calculation is printed.
years <- seq(from=0, to=nyears, by=1)   #Creates a sequence of numbers from 0 to the value stored in the object "nyears" (in this case, 50). Because you've told this sequence to increment by 1, you've created a string of numbers from 0 - 50 that contains 51 elements. A single series of elements (e.g., a single column of numbers) is called a vector. You then assign this vector to the object "years".
years                                   #Print the value of the object "years" that you just created.
N <- numeric(nyears+1)    #Make an empty storage vector. The numeric() function takes the contents within the parentheses and converts those contents to the "numeric" class. Don't worry if this doesn't make sense -- what you need to know is that the value within the parentheses (in this case, 50+1=51) is used to tell this function how many zeros to create. So, this line of code creates a vector of 51 zeros, and assigns that vector to the object "N".
N                         #Prints the contents of the object "N".
N[1] <- N0                # The brackets [] are used to indicate the position of an element within a vector. This line of code assigns the value of the object "N0" (100) to the first element in the "N" object. Remember, the "N" object is a vector of 51 zeros. Now, the first zero is changed to 100.
lambda <- 1 + r           # (1 + r) is equal to lambda, the finite rate of growth.  This stores the result of the calculation (1 + 0.1 = 1.1) in the object "lambda".
for (i in 2:(nyears+1)){  # This for-loop will run through the line of code between the curly brackets {}. "i" is simply the name of a variable (you can use "j", or "k", instead -- any variable name will do). "i" changes each time the loop iterates; basically, it will increase by 1 each time the loop is run, starting at "2" up until the specified maximum number of loops "50+1".
N[i] <- lambda*N[i-1]   # This takes the [i - 1] element of "N", multiplies that element by the value of lambda, then assigns that calculated result to the [i] element of "N".
}                         # This ends the for-loop.
N                         # Now print the contents of the object "N".
plot(N~years)   #This plot() function tells R to plot the y variable by the x variable. "N" is the y variable (dependent variable), and "years" is the x variable (independent variable). The tilda "~" stands for "as a function of". There are many ways to customize the appearance of a plot in R - for now, just use the defaults.
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
library(party)
?cforest
?cforest
cforest_unbiased()
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
install.packages("swirl")
library(swirl)
library(swirl)
swirl()
5+7
x = 5+7
x <- 5+7
x
y <- x-3
y
z<-c(1.1, 9, 3.14
)
?c
z
c(z,555,z)
z*2+100
my_sqrt <- sqrt(z-1)
my_sqrt
my_div <- z/my_sqrt
my_div
1:4+0:10
1:4+c(0,10)
c(1,2,3,4)+c(0,10)
c(1,2,3,4)+c(0,10,100)
c(1,2,3,4)+c(0,10,100)
z*2+100
(z*2+100)
(z * 2 + 100)
(z * 2 + 1000)
z*2+1000
my_div
swirl()
getwd()
ls()
x<-9
ls()
list.files()
?list.files
swirl()
ln(2)
log(2)
log(2)/0.1
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,500,1)  # create a sequence of numbers from 0 to 500, representing a range of population densities
## CONSTANTS
b_max <- 0.8  # maximum reproduction (at low densities)
d_min <- 0.3  # minimum mortality
a <- 0.001    # D-D terms
c <- 0.0005
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,1),main="Density-Dependence!",ylab="b or d")
points(Density,d,type="l",col="red",lwd=2)
axis(4,at=seq(0,1,0.2))
#mtext("d",4)
legend("bottomleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
log(7)/200
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
names(N) <- year
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
r <- 0.1     #Assign the value of 0.1 to the object "r", or per-capita growth rate (discrete)
lambda <- 1+r  # define lambda
N0 <- 100    #Assign the value of 100 to the object "N0", or initial population size
nyears <- 30 #Assign the value of 30 to the object "nyears", or the number of time steps to simulate
N0 * lambda   #Multiplies the value stored in the object "N0" by lambda. As soon as you run this line of code, the result of the calculation is printed.
year <- seq(from=0, to=nyears, by=1)   #Creates a sequence of numbers from 0 to the value stored in the object "nyears" (in this case, 50). Because you've told this sequence to increment by 1, you've created a string of numbers from 0 - 50 that contains 51 elements. A single series of elements (e.g., a single column of numbers) is called a vector. You then assign this vector to the object "years".
year                                   #Print the value of the object "years" that you just created.
N <- numeric(nyears+1)    #Make an empty storage vector. The numeric() function takes the contents within the parentheses and converts those contents to the "numeric" class. Don't worry if this doesn't make sense -- what you need to know is that the value within the parentheses (in this case, 50+1=51) is used to tell this function how many zeros to create. So, this line of code creates a vector of 51 zeros, and assigns that vector to the object "N".
names(N) <- year
N                         #Prints the contents of the object "N".
N['0']
N[0]
N[1]
N[1] <- N0                # The brackets [] are used to indicate the position of an element within a vector. This line of code assigns the value of the object "N0" (100) to the first element in the "N" object. Remember, the "N" object is a vector of 51 zeros. Now, the first zero is changed to 100.
for (i in 2:(nyears+1)){  # This for-loop will run through the line of code between the curly brackets {}. "i" is simply the name of a variable (you can use "j", or "k", instead -- any variable name will do). "i" changes each time the loop iterates; basically, it will increase by 1 each time the loop is run, starting at "2" up until the specified maximum number of loops "nyears+1".
N[i] <- N[i-1] * lambda  # This takes the [i - 1] element of "N", multiplies that element by the value of lambda, then assigns that calculated result to the [i] element of "N".
}                         # This ends the for-loop.
N                         # Now print the contents of the object "N".
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LAB1.Rmd")  ##
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,15000,10)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 0.85   # maximum reproduction (at low densities)
d_min <- 0.3  # minimum mortality (at low densities)
a <- 0.00007    # D-D terms
c <- 0.00003
b <- b_max - a*Density
d <- d_min + c*Density
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,15000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,500,1)  # create a sequence of numbers from 0 to 500, representing a range of population densities
## CONSTANTS
b_max <- 0.8  # maximum reproduction (at low densities)
d_min <- 0.3  # minimum mortality
a <- 0.001    # D-D terms
c <- 0.0005
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,1),main="Density-Dependence!",ylab="b or d")
points(Density,d,type="l",col="red",lwd=2)
axis(4,at=seq(0,1,0.2))
#mtext("d",4)
legend("bottomleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
Density <- seq(0,500,1)  # create a sequence of numbers from 0 to 500, representing a range of population densities
## CONSTANTS
b_max <- 0.8  # maximum reproduction (at low densities)
d_min <- 0.3  # minimum mortality
a <- 0.001    # D-D terms
c <- 0.0005
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,1),main="Density-Dependence!",ylab="b or d")
points(Density,d,type="l",col="red",lwd=2)
axis(4,at=seq(0,1,0.2))
#mtext("d",4)
legend("bottomleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
Density <- seq(0,500,1)  # create a sequence of numbers from 0 to 500, representing a range of population densities
## CONSTANTS
b_max <- 0.8  # maximum reproduction (at low densities)
d_min <- 0.3  # minimum mortality
a <- 0.001    # D-D terms
c <- 0.0005
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,1),main="Density-Dependence!",ylab="b or d")
lines(Density,d,col="red",lwd=2)
axis(4,at=seq(0,1,0.2))
#mtext("d",4)
legend("bottomleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
unlink("LECTURE4_cache", recursive = TRUE)
