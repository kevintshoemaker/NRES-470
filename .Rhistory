####  Matrix population models                          ####
############################################################
#########
# Teasel example from Gotelli: summarizing a complex life history!
teasel <- read.csv("teaselmatrix1.csv", header=T)      # read in the teasel transition matrix from Gotelli
teasel <- teasel[,-1]                                  # remove the row names
teasel_matrix <- as.matrix(teasel)                     # convert to a matrix (from a data frame)
colnames(teasel_matrix) <- names(teasel)               # assign row and column names
rownames(teasel_matrix) <- names(teasel)
teasel_matrix                                          # print the matrix
#############
# Summarize initial age-structured abundance as a matrix with one column
Initial_teasel <- matrix(c(1000,1500,200,300,600,25),ncol=1)         # initial population size (population vector; matrix with 1 column!)
rownames(Initial_teasel) <- rownames(teasel_matrix)                  # add row and column names
colnames(Initial_teasel) <- "Abundance"
Initial_teasel
#########
# Project the population at time 1
Year1 <- teasel_matrix %*% Initial_teasel   # note: the '%*%' denotes 'matrix multiplication' in R. We'll go through this more later.
Year1
#########
# Project the population at time 2
thisYear <- Year1
nextYear <- teasel_matrix %*% thisYear
nextYear  # now we get the (age structured) population size at time 2!
########
# Use a for loop to project the population dynamics for the next 10 years!
nYears <- 10
tenYears <- matrix(0,nrow=6,ncol=nYears+1)          # initialize storage array for recording age structured abundances for the next 10 years.
rownames(tenYears) <- rownames(Initial_teasel)      # assign row and column names
colnames(tenYears) <- seq(0,10)
tenYears[,1] <- Initial_teasel                      # initialize the simulated abundances
##########
# run the for loop!
for(t in 2:(nYears+1)){    # here we use 't' as our looping variable, but we could choose any name we want
tenYears[,t] <-  teasel_matrix %*% tenYears[,t-1]     # perform matrix multiplication for each year of the simulation!
}
tenYears
#########
# Plot the projected population trajectory over the next 10 years
plot(1,1,pch="",ylim=c(0,60000000),xlim=c(0,11),xlab="Years",ylab="Abundance",xaxt="n")    # make empty plot
cols <- rainbow(6)        # set colors for each stage
for(s in 1:6){
points(tenYears[s,],col=cols[s],type="l",lwd=2)       # plot out each stage
}
axis(1,at=seq(1,11),labels = seq(0,10))      # add x axis labels
legend("topleft",col=cols,lwd=rep(2,6),legend=rownames(tenYears))      # add legend
###########
# Use the transition matrix to compute Lambda, or the finite rate of population growth!
library(popbio)      # load the 'popbio' package in R!
Lambda <- lambda(teasel_matrix)
Lambda
#   as.numeric(round(eigen(teasel_matrix)$values[1],2))  # this is an alternative method- if you don't want to use the 'popbio' package
##########
# Compute stable age distribution from the transition matrix!
library(popbio)    # ... and it's even easier if we use the 'popbio' package...
SAD <- stable.stage(teasel_matrix)
SAD      # stable age distribution as a percentage of the total population
# #abs(as.numeric(round(eigen(teasel_matrix)$vectors[,1],3)))  # alternative- doesn't use 'popbio'
# SAD/sum(SAD)
###################
# In class demo: convert an insightmaker model to a matrix projection model
###########
# First, we specify a blank transition matrix
TMat <- matrix(0,nrow=3,ncol=3)                    # create a blank matrix with 3 rows and 3 columns
stagenames <- c("Juveniles","Subadults","Adults")  # name the rows and columns
rownames(TMat) <- stagenames
colnames(TMat) <- stagenames
TMat                                               # now we have an all-zero transition matrix.
#####
# fill in the top left element of the matrix
TMat[1,1] <- 0
TMat
#####
# update the second row, first column
TMat[2,1] <- 0.3
TMat
#####
# and keep filling it in...
TMat[,1] <- c(0,0.3,0)          # fill in the entire first column of the transition matrix
TMat[,2] <- c(0,0.4,0.1)        # fill in the entire second column of the transition matrix
TMat[,3] <- c(4,0,0.85)         # fill in the entire third column of the transition matrix
TMat
######
# specify initial abundance vector
InitAbund <- c(40,0,0)
names(InitAbund) <- colnames(TMat)
InitAbund
#######
# Run the model for 40 years (using for loop)
nYears <- 40
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)
rownames(allYears) <- rownames(TMat)
colnames(allYears) <- seq(0,nYears)
allYears[,1] <- InitAbund
for(t in 2:(nYears+1)){
allYears[,t] <-  TMat %*% allYears[,t-1]
}
allYears
#####
# and plot out the results!
plot(1,1,pch="",ylim=c(0,50),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")
cols <- rainbow(3)
for(s in 1:3){
points(allYears[s,],col=cols[s],type="l",lwd=2)
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))
legend("topleft",col=cols,lwd=rep(2,3),legend=rownames(allYears))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#############
# Random number generation!
#####
# define an arbitrary distribution
box <- c(rep(1,10),rep(2,5),rep(3,2))                                           # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
barplot(table(box)/sum(table(box)),ylab="probability",xlab="possibility")       # visualize the distribution of possibilities
############
# Log-normal distribution
meanlog = 1.4
stdevlog = 0.6
curve(dlnorm(x,meanlog,stdevlog),0,15,ylab="Probability (density)",xlab="Possibilities",main="Lognormal distribution (continuous)")   # probability density
############
# Try to identify a lognormal random number distribution to represent the canvasback data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
#############
# Demonstration: use data to determine a distribution!
#############
#############
# Made-up canvasback data- average number of eggs hatched per female for 20 years
hatch_perfem <- c(3.05, 1.45, 0.99, 3.24, 1.49, 1.70, 1.66, 2.32, 0.83, 2.41,
2.33, 1.68, 1.43, 2.74, 2.05, 3.13, 1.90, 3.69, 1.55, 2.79)
hist(hatch_perfem)
############
# Try to identify a lognormal random number distribution to represent the canvasback data
## first, plot a histogram of the data from the 20-year study
hist(hatch_perfem,freq=F,main="Histogram of avg number hatched per female",xlab="possibilities",ylab="probability",xlim=c(0,10),ylim=c(0,1))
## now, overlay a lognormal probability distribution with arbitrary parameters (meanlog and sdlog). This is just a starting point.
curve(dlnorm(x,meanlog=1.5,sdlog=0.39),col="green",lty=2,lwd=2,add=T)
curve(dlnorm(x,meanlog=1.8,sdlog=0.39),col="green",lty=2,lwd=2,add=T)    # try a different value...
#### Keep changing the value for 'meanlog' until you find best parameters to fit the data!
#### Once you find the best-fit parameters, generate 5 random numbers from this distribution using the "rlnorm()" function in R
rlnorm(5,meanlog=1.5,sdlog=0.39)    # for example! (remember to change the "meanlog" parameter to the value you identified above!)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
###############
# Review random number generators:
# Poisson distribution
hist(rpois(10000,(100*0.8)),main="",freq = F,ylab="Probability",xlab="Possibilities (Total Births)")
# Binomial distribution
hist(rbinom(10000,100,0.2),main="",xlab="Possibilities (Total Deaths)",freq = F,ylab="Probability")
# Uniform distribution
hist(runif(10000,0.8,1.7),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
1.7-0.8
(1.7-0.8)/2
+0.8
(1.7-0.8)/2+0.8
0.45/2
# Uniform distribution
hist(rnorm(10000,mean=1.25,sd=0.23),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
# Uniform distribution
hist(rnorm(10000,mean=1.25,sd=0.22),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
# Uniform distribution
hist(rnorm(10000,mean=1.25,sd=0.21),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
# Uniform distribution
hist(rnorm(10000,mean=1.25,sd=0.2),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
# Uniform distribution
hist(rnorm(10000,mean=1.25,sd=0.15),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
# Normal distribution
hist(rnorm(10000,mean=1.1,sd=0.4),main="",xlab="Possibilities (annual birth rates)",freq = F,ylab="Probability")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE17.Rmd")
rmd2rscript("LAB4.Rmd")  ##
rmd2rscript("LAB5.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# Run the matrix projection model!
nYears <- 100                                            # set the number of years to project
TMat <- projection_matrix                               # define the projection matrix
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  NRES 421, PVA                                     ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  Loggerhead example                                ####
############################################################
##### specify projection matrix!
projection_matrix <- matrix(
c(
0,     0,      0,      4.665,      61.896,
0.675, 0.703,  0,      0,          0,
0,     0.047,  0.657,  0,          0,
0,     0,      0.019,  0.682,      0,
0,     0,      0,      0.061,      0.809
)
,nrow=5,ncol=5,byrow=T
)
stagenames <- c("Hatchling","Small Juv","Large Juv","Subadult","Adult")
rownames(projection_matrix) <- stagenames
colnames(projection_matrix) <- stagenames
projection_matrix
# Run the matrix projection model!
nYears <- 100                                            # set the number of years to project
TMat <- projection_matrix                               # define the projection matrix
Abundance_year0 <- c(2000,500,300,300,20)   # vector of initial abundances
InitAbund <- Abundance_year0                            # define the initial abundance
## NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all abundances!
allYears[,1] <- InitAbund  # set the year 0 abundance
for(t in 2:(nYears+1)){   # loop through all years
allYears[,t] <-  TMat %*% allYears[,t-1]
}
plot(1,1,pch="",ylim=c(0,max(allYears)),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")  # set up blank plot
cols <- rainbow(5)    # set up colors to use
for(s in 1:5){
points(allYears[s,],col=cols[s],type="l",lwd=2)     # plot out each life stage abundance, one at a time
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))   # label the axis
legend("topright",col=cols,lwd=rep(2,3),legend=rownames(TMat),bty="n")  # put a legend on the plot
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE12.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  NRES 470, Lecture 12                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  Population Viability Analysis                     ####
############################################################
##############
# Demonstration PVA
##############
# STEP 1: conceptualize life history (we are modeling this population as a simple, single-stage stochastic model with density dependence)
# STEP 2: parameterize the model
####
# Basic life history parameters
####
R_max <- 1.15       # Maximum rate of growth
Init_N <- 51        # Initial abundance
K <- 175            # Carrying capacity
####
# Environmental stochasticity
####
SD_anngrowth <- 0.11  # standard deviation of annual growth rate
####
# Density-dependence (Ricker model)
####
Ricker <- function(prev_abund){       # this is a function for computing next-year abundance -- includes env stochasticity
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
####
# Catastrophe
####
Flood_prob <- 0.05      # 5% chance of major flood
Flood_lambda <- 0.25    # 25% of population can survive a flood
# STEP 3: add spatial structure (not applicable here)
# STEP 4: simulate!
####
# Basic simulation parameters
####
nyears <- 100     # number of years
nreps <- 500      # number of replicates
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # set up storage array
## start looping through replicates
for(rep in 1:nreps){
# set initial abundance
PopArray2[1,rep] <- Init_N     # set the initial abundance
### loop through years
for(y in 2:(nyears+1)){
### stochasticity and d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catastrophe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
# STEP 5: results
############
# Graphical visualization
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualize extinction rates over time
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualize final abundance after 100 years relative to initial abundance
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of decline
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
# Plot extinction risk as a function of flood severity
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
16+17+31
60*3*5
1-0.85^10
(1-0.85^10)^5
(1-0.85^10)^15
0.75*0.75
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
temp <- read.table("E:\\MARK\\Examples\\markdata\\simple_closed1.inp",colClasses = "character",header=FALSE)
temp2 <- as.data.frame(matrix(unlist(strsplit(temp[,1],split="")),ncol=6,byrow=T))
temp2$times <- as.numeric(gsub(";","",temp$V2))
temp3 <- temp2[rep(c(1:nrow(temp2)),times=as.numeric(temp2$times)),]
temp3 <- temp3[,-c(ncol(temp3))]
names(temp3) <- c("sample1","sample2","sample3","sample4","sample5","sample6")
setwd("E:\\GIT\\NRES-470")
write.table(temp3,file="simple_closed.csv",row.names=FALSE,col.names=TRUE,sep=",")
##########
# CLOSED POPULATION MODELS
##########
# Note: I recommend doing these lab activities in EXCEL, but you're more than welcome to try to do it in R (instead of handing in your work as an excel spreadsheet, just hand in your R code!)
###########
# First, load up the CSV file (you need to download it first)
# setwd()     # remember to set your working directory before you read in the data!
head(read.csv("simple_closed.csv"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#######
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
######
# Numerical response
LVnumresp <- function(V,beta){
beta*V
}
curve(LVnumresp(x,0.001),0,200,xlab="Victim abundance",ylab="Increase in r for predator population",col="blue",lwd=3)
5+4*3+3*4
100-29
5*2+4*3+3*4
6*6+7*3+9
3*3+4*4+5+8*2
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('index.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
unlink("schedule_cache", recursive = TRUE)
rmarkdown::render('schedule.Rmd', 'word_document')
log(2)
0.7/10
70/10
70/7
ln(2)/.07
log(2)/.07
10*e^(.1)
10*exp(.1)
10*exp(.1*10)
10*exp(.1)/10
ln(1.1)
log(1.1)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
#################
Base_ms = 16000     # annual
Base_PhD = 20000   # annual
Tuition_res_9cred = 2826*2    # annual
Benefits = 1788 + 2477   # annual
Tuition_nonres = 8271*2  # annual (for nonresidents)
MS_yrs = 2
PhD_yrs = 5
TotVal_res_ms = Base_ms*MS_yrs +  (Tuition_res_9cred*MS_yrs)*0.75 + Benefits*MS_yrs
TotVal_nonres_ms = Base_ms*MS_yrs +  (Tuition_res_9cred*MS_yrs)*0.75 + Benefits*MS_yrs + Tuition_nonres*MS_yrs
TotVal_res_phd = Base_PhD*PhD_yrs +  (Tuition_res_9cred*PhD_yrs)*0.75 + Benefits*PhD_yrs
TotVal_nonres_phd = Base_PhD*PhD_yrs +  (Tuition_res_9cred*PhD_yrs)*0.75 + Benefits*PhD_yrs + Tuition_nonres*PhD_yrs
#################
TotVal_nonres_ms
