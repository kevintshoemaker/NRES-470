#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE12.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
############################################################
####                                                    ####
####  NRES 470, Lecture 12                               ####
####                                                    ####
####  Kevin Shoemaker                                   ####
####  University of Nevada, Reno                        ####
####                                                    ####
############################################################
############################################################
####  Population Viability Analysis                     ####
############################################################
##############
# Demonstration PVA
##############
# STEP 1: conceptualize life history (we are modeling this population as a simple, single-stage stochastic model with density dependence)
# STEP 2: parameterize the model
####
# Basic life history parameters
####
R_max <- 1.15       # Maximum rate of growth
Init_N <- 51        # Initial abundance
K <- 175            # Carrying capacity
####
# Environmental stochasticity
####
SD_anngrowth <- 0.11  # standard deviation of annual growth rate
####
# Density-dependence (Ricker model)
####
Ricker <- function(prev_abund){       # this is a function for computing next-year abundance -- includes env stochasticity
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
####
# Catastrophe
####
Flood_prob <- 0.05      # 5% chance of major flood
Flood_lambda <- 0.25    # 25% of population can survive a flood
# STEP 3: add spatial structure (not applicable here)
# STEP 4: simulate!
####
# Basic simulation parameters
####
nyears <- 100     # number of years
nreps <- 500      # number of replicates
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # set up storage array
## start looping through replicates
for(rep in 1:nreps){
# set initial abundance
PopArray2[1,rep] <- Init_N     # set the initial abundance
### loop through years
for(y in 2:(nyears+1)){
### stochasticity and d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catastrophe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
### Run the PVA!
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
# STEP 5: results
############
# Graphical visualization
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualize extinction rates over time
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualize final abundance after 100 years relative to initial abundance
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of decline
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
# Plot extinction risk as a function of flood severity
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
16+17+31
60*3*5
1-0.85^10
(1-0.85^10)^5
(1-0.85^10)^15
0.75*0.75
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
temp <- read.table("E:\\MARK\\Examples\\markdata\\simple_closed1.inp",colClasses = "character",header=FALSE)
temp2 <- as.data.frame(matrix(unlist(strsplit(temp[,1],split="")),ncol=6,byrow=T))
temp2$times <- as.numeric(gsub(";","",temp$V2))
temp3 <- temp2[rep(c(1:nrow(temp2)),times=as.numeric(temp2$times)),]
temp3 <- temp3[,-c(ncol(temp3))]
names(temp3) <- c("sample1","sample2","sample3","sample4","sample5","sample6")
setwd("E:\\GIT\\NRES-470")
write.table(temp3,file="simple_closed.csv",row.names=FALSE,col.names=TRUE,sep=",")
##########
# CLOSED POPULATION MODELS
##########
# Note: I recommend doing these lab activities in EXCEL, but you're more than welcome to try to do it in R (instead of handing in your work as an excel spreadsheet, just hand in your R code!)
###########
# First, load up the CSV file (you need to download it first)
# setwd()     # remember to set your working directory before you read in the data!
head(read.csv("simple_closed.csv"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#######
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
######
# Numerical response
LVnumresp <- function(V,beta){
beta*V
}
curve(LVnumresp(x,0.001),0,200,xlab="Victim abundance",ylab="Increase in r for predator population",col="blue",lwd=3)
5+4*3+3*4
100-29
5*2+4*3+3*4
6*6+7*3+9
3*3+4*4+5+8*2
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('index.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
unlink("schedule_cache", recursive = TRUE)
rmarkdown::render('schedule.Rmd', 'word_document')
log(2)
0.7/10
70/10
70/7
ln(2)/.07
log(2)/.07
10*e^(.1)
10*exp(.1)
10*exp(.1*10)
10*exp(.1)/10
ln(1.1)
log(1.1)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
#################
Base_ms = 16000     # annual
Base_PhD = 20000   # annual
Tuition_res_9cred = 2826*2    # annual
Benefits = 1788 + 2477   # annual
Tuition_nonres = 8271*2  # annual (for nonresidents)
MS_yrs = 2
PhD_yrs = 5
TotVal_res_ms = Base_ms*MS_yrs +  (Tuition_res_9cred*MS_yrs)*0.75 + Benefits*MS_yrs
TotVal_nonres_ms = Base_ms*MS_yrs +  (Tuition_res_9cred*MS_yrs)*0.75 + Benefits*MS_yrs + Tuition_nonres*MS_yrs
TotVal_res_phd = Base_PhD*PhD_yrs +  (Tuition_res_9cred*PhD_yrs)*0.75 + Benefits*PhD_yrs
TotVal_nonres_phd = Base_PhD*PhD_yrs +  (Tuition_res_9cred*PhD_yrs)*0.75 + Benefits*PhD_yrs + Tuition_nonres*PhD_yrs
#################
TotVal_nonres_ms
20*4
66015/2
(66015/2)/12
2000*12*2
6*20
120*3
2250*12
2250*12*2
2300*12*2
2250*12*2
2250*2
4500*0.8
3600*3
5/40
4500*0.125
562.5/4500
14625-9000
2250*12
4500*3
4500*3*0.8
25*6*20
45/85
10*.53
5*2.1
10.5+18
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# Normal distribution
hist(rnorm(10000,mean=1.25,sd=0.15),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#  NRES 470, Lab 5    ------------------------------------
#  University of Nevada, Reno
#  Stochasticity and Uncertainty
# Review random number generators in R ----------------------
# Poisson distribution (often used for modeling total annual births in a population)
hist(rpois(10000,(100*0.8)),main="",freq = F,ylab="Probability",xlab="Possibilities (Total Births)")
# Binomial distribution (often used to represent total survivors or deaths in a population model )
hist(rbinom(10000,100,0.2),main="",xlab="Possibilities (Total Deaths)",freq = F,ylab="Probability")
# Normal distribution (often used to model environmental stochasticity)
hist(rnorm(10000,mean=1.25,sd=0.15),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
hist(rnorm(10000,mean=1.1,sd=0.4),main="",xlab="Possibilities (annual birth rates)",freq = F,ylab="Probability")
curve(dnorm(x,1.1,0.4),0,3)
curve(dnorm(x,1.1,0.4),0,3,xlab="Possibilities (annual birth rates)",freq = F,ylab="Probability"))
curve(dnorm(x,1.1,0.4),0,3,xlab="Possibilities (annual birth rates)",freq = F,ylab="Probability")
curve(dnorm(x,1.1,0.4),0,3,xlab="Possibilities (annual birth rates)",ylab="Probability")
curve(dnorm(x,1.1,0.4),0,3,xlab="Possibilities (annual birth rates)",ylab="Probability",lwd=3)
curve(dnorm(x,1.25,0.15),0,3,lwd=3,add=T)
# Normal distribution (often used to model environmental stochasticity)
hist(rnorm(10000,mean=1.25,sd=0.15),main="",freq=F,xlab="Possibilities (annual birth rates)",ylab="Probability")
curve(dnorm(x,1.25,0.15),0,3,lwd=3,add=T)
unlink("LAB5_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LAB5.Rmd")
rmd2rscript("LAB4.Rmd")  ##
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# Random number generation! ----------------
# define an arbitrary distribution
box <- c(rep(1,10),rep(2,5),rep(3,2))                                           # define what's in the lottery ball machine (10 "1" balls, 5 "2" balls and 2 "3" balls)
barplot(table(box)/sum(table(box)),ylab="probability",xlab="possibility")       # visualize the distribution of possibilities
# Discrete distributions ----------------------------
# binomial distribution ('coin flipping' distribution, often used to model total survivors/mortalities)
# plot a discrete distribution!
xvals <- seq(0,10,1)
probs <- dbinom(xvals,10,prob=0.3)
names(probs) <- xvals
barplot(probs,ylab="Probability",xlab="Possibilities",main="Binomial distribution (discrete)")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#  NRES 470/670, Lecture 12 -----------------------
#   University of Nevada, Reno
#   Population Viability Analysis
# Demonstration PVA ---------------------------------
# STEP 1: conceptualize life history (we are modeling this population as a simple, single-stage stochastic model with density dependence)
# STEP 2: parameterize the model ---------------------------------
# Basic life history parameters
R_max <- 1.15       # Maximum rate of growth
Init_N <- 51        # Initial abundance (not stage structured)
K <- 175            # Carrying capacity
# Environmental stochasticity ------------------------------------
SD_anngrowth <- 0.11  # standard deviation of annual growth rate
# Density-dependence (Ricker model) ----------------------------------
Ricker <- function(prev_abund){       # this is a function for computing next-year abundance -- includes env stochasticity
prev_abund * exp(log(rnorm(1,R_max,SD_anngrowth))*(1-(prev_abund/K)))
}
# Catastrophe -------------------------
Flood_prob <- 0.05      # 5% chance of major flood
Flood_lambda <- 0.25    # 25% of population can survive a flood
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # set up storage array
## start looping through replicates
for(rep in 1:nreps){
# set initial abundance
PopArray2[1,rep] <- Init_N     # set the initial abundance
### loop through years
for(y in 2:(nyears+1)){
### stochasticity and d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catastrophe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
nyears <- 100     # number of years
nreps <- 500      # number of replicates
PVAdemo <- function(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda){
#browser()
PopArray2 <- array(0,dim=c((nyears+1),nreps))   # set up storage array
## start looping through replicates
for(rep in 1:nreps){
# set initial abundance
PopArray2[1,rep] <- Init_N     # set the initial abundance
### loop through years
for(y in 2:(nyears+1)){
### stochasticity and d-d
nextyear <- max(0,trunc(Ricker(PopArray2[y-1,rep])))
### catastrophe
if(runif(1)<Flood_prob) nextyear <- nextyear*Flood_lambda
PopArray2[y,rep] <- nextyear
}
}
return(PopArray2)
}
Default <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,Flood_lambda)
Default
PlotCloud <- function(simdata){
plot(c(1:101),simdata[,1],col=gray(0.7),type="l",ylim=c(0,max(simdata)),xlab="Years",ylab="Abundance")
for(r in 2:ncol(simdata)){
lines(c(1:101),simdata[,r],col=gray(0.7),type="l")
}
}
PlotCloud(Default)
# Visualize extinction rates over time
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualize final abundance after 100 years relative to initial abundance
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of decline
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
simdata
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
View(Default)
# Visualize extinction rates over time
Extinction_byyear <- function(simdata){
apply(simdata,1,function(t)  length(which(t==0)))/ncol(simdata)
}
plot(c(1:101),Extinction_byyear(Default),type="l",lwd=2,xlab="year",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
# visualize final abundance after 100 years relative to initial abundance
hist(Default[nrow(Default),],xlab="Final abundance after 100 years",ylab="Number of replicates",main="")
abline(v=Init_N,col="green",lwd=2)
# plot probabilities of different severities of decline
declines <- seq(0,100,by=1)
declineprob <- numeric(length(declines))
for(s in 1:length(declines)){
declineprob[s] <- length(which(Default[nrow(Default),]<(Init_N-(declines[s]/100)*Init_N)))/ncol(Default)
}
plot(declines,declineprob,type="l",lwd=2,xlab="Decline threshold (percent)",ylab="Probability of falling below threshold")
abline(v=25,col="red",lwd=2)
# Plot extinction risk as a function of flood severity
Exctinction_risk <- function(simdata){
length(which(simdata[nrow(simdata),]==0))/ncol(simdata)
}
flood_lambdas <- seq(0.9,0.1,by=-0.05)
all_scenarios <- numeric(length(flood_lambdas))
for(scenario in 1:length(flood_lambdas)){
PVA <- PVAdemo(nreps,nyears,Init_N,R_max,K,Flood_prob,flood_lambdas[scenario])
all_scenarios[scenario] <- Exctinction_risk(PVA)
}
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (lambda in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
flood_lambdas
plot(1-flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (survival in flood year)",ylab="extinction risk")
flood_lambdas
plot(flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (survival in flood year)",ylab="extinction risk")
all_scenarios
1-flood_lambda
1-flood_lambdas
plot(1-flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (mortality in flood year)",ylab="extinction risk")
plot(1-flood_lambdas,all_scenarios,type="p",cex=2,xlab="flood impact (mortality in flood year)",ylab="extinction risk")
abline(h=0.05,col="red",lwd=2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB6.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE17.Rmd")
rmd2rscript("LAB7.Rmd")
20/6
20/3
log(9)
