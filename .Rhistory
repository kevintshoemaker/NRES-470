out=ode(times=seq(0,maxtime,length=Tlen),y=c(x0[1],x0[2]),func=as.ode.func(fun),parms=parms,...);
return(out);
})
traj.backward = compiler::cmpfun(function(x0,fun,parms,maxtime,Tlen=500,...){
out=ode(times=seq(0,-maxtime,length=Tlen),y=c(x0[1],x0[2]),func=as.ode.func(fun),parms=parms,...);
return(out[nrow(out):1,]);
})
## 5. traj.continue()
traj.continue <- compiler::cmpfun(function(fun, parms, tdat, maxtime, Tlen=500, backward=FALSE, ...){
if(length(tdat)==0) { cat("WARNING: No trajectories have been calculate yet!\n")}
out.curr <- tdat[[length(tdat)]]
if(backward) {
X0=head(out.curr,1);
t0=X0[1];
x0=X0[-1];
times=t0+seq(0,-maxtime,length=Tlen);
out=ode(times=times,y=x0,func=as.ode.func(fun),parms=parms,...);
return(rbind(out[nrow(out):2,],out.curr));
} else {
X0=tail(out.curr,1);
t0=X0[1]
x0=X0[-1]
times=t0+seq(0,maxtime,length=Tlen);
out=ode(times=times,y=x0,func=as.ode.func(fun),parms=parms,...);
return(rbind(out.curr,out[-1,]));
}
})
## original grid() function
grid=compiler::cmpfun(function(fun,xlim,ylim,parms,ngrid,maxtime=50,Tlen=500,add=F,color="blue") {
if (add==F) {
plot(1,xlim=xlim, ylim=ylim, type='n',xlab="x",ylab="y");
}
xvals=seq(xlim[1],xlim[2],length=ngrid);
yvals=seq(ylim[1],ylim[2],length=ngrid);
for(i in 1:ngrid) {
for(j in 1:ngrid) {
out=ode(times=seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
out=ode(times=-seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
}}
})
# Newton's method to find equilibria of vector field.
# func() must have the same input arguments and returns as for ode/rk4.
# Inputs:
#   x0 = intial guess at equilibrium. If x0 is not supplied in the call,
#        the user chooses it from the current graphics device via locator()
#         and the equilibrium is plotted to the same device. Plotting
#         symbol is closed/open=stable/unstable, circle/triangle=eigenvalues imaginary/real.
#   tol= Convergence tolerance
#   niter = Maximum number of iterations
#   inc = finite-difference increment for derivative estimates
# Coded 5/25/06 by SPE based on Matlab toggle.m by JG
# MODIFIED 7/2016 by PJH to take functions fun(x,y,parms)
newton=compiler::cmpfun(function(fun,x0=NULL,parms=NULL,tol=1e-16,niter=40,inc=1e-6,plotit=TRUE) {
x=x0; #initial x
if (is.null(x0)) {
warning("Oops! newton() was called without x0 specified!");#{x = locator(n=1); x=c(x$x,x$y)};
return(list(x=c(NA,NA,df=matrix(NA,2,2),pch=NA)))
}
nx = length(x); # length of state vector
######### Newton iteration loop: start
for(i in 1:niter){
y = as.ode.func(fun)(0,x,parms)[[1]]
df = matrix(0,nx,nx); # Compute df
for(j in 1:nx) {
#Increment vector for estimating derivative wrt jth coordinate
v=rep(0,nx);
v[j] = inc;
df[,j]=  (as.ode.func(fun)(t,x+v,parms)[[1]] - as.ode.func(fun)(t,x-v,parms)[[1]])/(2*inc)
}
if (sum(y^2) < tol){  #check for convergence
if(plotit){
ev=eigen(df)$values; pch1=1+as.numeric(Im(ev[1])!=0); pch2=1+as.numeric(max(Re(ev))<0);
pchs=matrix( c(2,17,1,16),2,2,byrow=T);
#points(x[1],x[2],type="p",pch=pchs[pch1,pch2],cex=1.5)
}
cat("Fixed point (x,y) = ",x,"\n");
cat("Jacobian Df=","\n"); print(df);cat("Eigenvalues","\n"); print(eigen(df)$values)
return(list(x=x,df=df,pch=pchs[pch1,pch2]))
} # end convergence check
x = x - solve(df,y) # one more step if needed
cat(i, x, "\n") #print out the next iterate
}
######### Newton iteration loop: end
cat("Convergence failed");
})
## to draw fixed points
fixed.points.draw <- compiler::cmpfun(function(FPs) {
for(i in 1:length(FPs)) { points(FPs[[i]]$x[1], FPs[[i]]$x[2], cex=1.5, type="p",pch=FPs[[i]]$pch)}
})
manifolds.calc <- compiler::cmpfun(function(fun,parms,FPs,maxtime=250, Tlen=500) {
ms = list()
for(i in 1:length(FPs)) { if(!any(is.na(FPs[[i]]$x))) {
x=FPs[[i]]$x; df=FPs[[i]]$df; V=eigen(df)$vectors; ev=eigen(df)$values;
if (sign(Re(ev[1])) != -sign(Re(ev[2])) | Im(ev[1]) != 0) {
# if not a saddle...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}else{
i1=which(Re(ev)>0); i2=which(Re(ev)<0);
v1=V[,i1]; v2=V[,i2]; eps=1e-3;
out1=ode(y=x+eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out2=ode(y=x-eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out3=ode(y=x+eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out4=ode(y=x-eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
S = rbind(out3,out4[1,]*NA,out4)[,-1]
U = rbind(out1,out2[1,]*NA,out2)[,-1]
ms[[i]] <- list(S=S,U=U)
}} else { # if x[1] is NA...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}
}
return(ms)
})
manifolds.draw=compiler::cmpfun(function(ms) {
for(i in 1:length(ms)){
S=ms[[i]]$S
U=ms[[i]]$U
title(sub="Black=stable manifold, Red=unstable manifold");
points(S[,1],S[,2],type="l",lwd=2,col="black");
points(U[,1],U[,2],type="l",lwd=2,col="red");
}
})
# Compute Jacobian of a planar vector field at a point (x,y),
# either input or chosen with locator().
jacobianAtXY <- compiler::cmpfun(function(fun,x=NULL, y=NULL,inc=1e-7){
if (is.null(x)|is.null(y)) {
x0 <- locator(n=1); x <- x0$x; y <- x0$y;
}
foo <- fun(x,y); h = inc;
foox <- fun(x+h,y); fooy <- fun(x,y+h);
A <- (foox[1] - foo[1])/h;
B <- (fooy[1] - foo[1])/h;
C <- (foox[2] - foo[2])/h;
D <- (fooy[2] - foo[2])/h;
return(matrix( c(A,B,C,D ),2,2,byrow=T))
})
##########
# Visualize phase plane with arrows!
##########
#######################################################################################
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]*(1-(u+(parms[2]*v))/parms[3]), v*parms[4]*(1-(v+(parms[5]*u))/parms[6]) )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Rmax1 <- 0.05
Alpha <- 0.3
K1 <- 1000
Rmax2 <- 0.3
Beta <- 0.2
K2 <- 450
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,2000)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
#
## END MODEL SPECIFICATION AND INITIALIZATION
#######################################################################################
#### example with phase-plane arrows
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 1
##########
# Another example
##########
Rmax1 <- 0.2
Alpha <- 1.1
K1 <- 1000
Rmax2 <- 0.2
Beta <- 0.9
K2 <- 500
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
#########
# And another example!
#########
Rmax1 <- 0.5
Alpha <- 1.05
K1 <- 890
Rmax2 <- 0.2
Beta <- 0.5
K2 <- 890
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
########
# And another!
#########
Alpha <- 0.3
Beta <- 0.2
K1 <- 1000
K2 <- 450
Rmax1 <- 0.05
Rmax2 <- 0.3
Nyears <- 1000
ylim=c(0,K2*1.5)
xlim=c(0,K1*1.5)
plot(1,1,pch="",ylim=ylim,xlim=xlim,xlab="species 1",ylab="species 2")
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.4)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.4)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.4)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.4)
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=15,parms=parms)
phasearrows.draw(new)
abline(h=K2,v=K1,col="gray",lwd=2,lty=2)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=2)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=2)   # species 2
########
# And finally...
########
Rmax1 <- 0.2
Alpha <- 1.5
K1 <- 1000
Rmax2 <- 0.2
Beta <- 2
K2 <- 1500
parms=c(Rmax1,Alpha,K1,Rmax2,Beta,K2)
# toggle(100,100,parms)
xlim = c(5,1500)
ylim = c(5,1000)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="N1",ylab="N2")
phasearrows.draw(new)
abline(K1/Alpha,-(K1/Alpha)/K1,col="red",lwd=3)   # species 1
abline(K2,-K2/(K2/Beta),col="blue",lwd=3)   # species 2
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE16.Rmd',rmarkdown::pdf_document())
rmarkdown::render('FINAL_PROJECTS.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#######
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
unlink('LECTURE17_cache', recursive = TRUE)
######
# Numerical response
LVnumresp <- function(V,beta){
beta*V
}
curve(LVnumresp(x,0.001),0,200,xlab="Victim abundance",ylab="Increase in r for predator population",col="blue",lwd=3)
##### LOTKA VOLTERRA PREDATION EXAMPLE (on phase plane)
## Params
Alpha <- 0.001
Beta <- 0.001
InitPrey <- 100
InitPred <- 75
r <- 0.1
q <- 0.1
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
plot(1,1,pch="",ylim=c(0,200),xlim=c(0,200),xlab="prey",ylab="predators")
points(System[seq(1,1000,10),],col="green",type="p",pch=20,cex=0.85)
points(System[1,],col="blue",pch=20,cex=3)
#######################################################################################
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]-parms[2]*u*v - parms[3]*u^2, parms[4]*u*v-parms[5]*v )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
parms=c(r,Alpha,c,Beta,q)
# toggle(100,100,parms)
xlim = c(5,200)
ylim = c(5,200)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
TypeIIfuncresp <- function(V,alpha,h){
(alpha*V)/(1+alpha*h*V)
}
curve(TypeIIfuncresp(x,0.1,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
TypeIIIfuncresp <- function(V,alpha,h,k){
(alpha*V^k)/(1+alpha*h*V^k)
}
curve(TypeIIIfuncresp(x,0.0005,0.1,1.6),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE17.Rmd',rmarkdown::pdf_document())
rmarkdown::render('EXTRA_CREDIT.Rmd',rmarkdown::pdf_document())
citation('vegan')
citation('jagsUI')
6/8
unlink('LECTURE18_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE18.Rmd',rmarkdown::pdf_document())
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE18.Rmd',rmarkdown::pdf_document())
install.packages("FLightR")
N=numeric(31)
names(N)=0:30
N
N[0]
N["0"]
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
54/3
27*3
46*3
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,15000,10)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 0.9   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00006    # D-D terms
c <- 0.00002
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,15000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
(b-d)/(a+c)
a <- 0.00006    # D-D terms
c <- 0.00002
b <- b_max - a*Density
d <- d_min + c*Density
(b-d)/(a+c)
(b_max-d_min)/(a+c)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table2.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Elephant_age <- seq(0,60,by=2)
Birth_rate <- c(rep(0,times=7),seq(0,0.3,length=4),rep(0.3,times=15),seq(0.3,0,length=5))
names(Birth_rate) <- Elephant_age
barplot(Birth_rate,xlab="Age",ylab="b, per-capita birth rate",col="blue",ylim=c(0,0.5))
Tortoise_age <- seq(0,120,by=5)
Death_rate <- c(seq(0.7,0.05,length=5),seq(0.02,0.02,length=16),seq(0.02,0.5,length=4))
names(Death_rate) <- Tortoise_age
barplot(Death_rate,xlab="Age",ylab="d, per-capita death rate",col="blue")
lifetable <- read.csv("life_table.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)","l(x)","g(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table2.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
lifetable <- read.csv("life_table2.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
unlink('LAB3_cache', recursive = TRUE)
rmarkdown::render('LAB3.Rmd',rmarkdown::pdf_document())
2*log(5)
log(5^2)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('FINAL_PROJECTS.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE7.Rmd',rmarkdown::pdf_document())
unlink('LAB4_cache', recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
lifetable <- read.csv("life_table4.csv")
lifetable
stmat <- read.csv("stage_matrix1.csv")
stmat <- as.matrix(stmat[,-1])
rownames(stmat) <- colnames(stmat)
stmat
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
library(qdapDictionaries)
mydict <- qdapDictionaries::GradyAugmented  #[1:10000]  # clearly not the one used by NYT!
mydict <- mydict[!grepl("'",mydict)]
mydict <- mydict[!grepl("-",mydict)]
mydict <- mydict[nchar(mydict)>3]
today <- c("a","h","t","d","o","i","n")  # first word is center
allowed <- sprintf("[%s]",paste(today,collapse=""))
not_allowed <- sprintf("^[^%s]+$",paste(setdiff(letters,today),collapse=""))
allowed_words <- mydict[grepl(not_allowed,mydict)]
correct_words <- allowed_words[grepl(today[1],allowed_words)]
correct_words
250/4
8125*0.65/4
6*4.5+2*3.3
58+45+_33
58+45+33
136*(85/400)
# age 3
10*(31/40)
# age 4
10*(5/31)
8*4.5+2*3.3
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
stmat <- read.csv("stage_matrix1.csv")
stmat <- as.matrix(stmat[,-1])
rownames(stmat) <- colnames(stmat)
stmat
library(popbio)
lambda(stmat)
stmat
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE9.Rmd',rmarkdown::pdf_document())
sqrt(100/40)
ln(100/40)/2
log(100/40)/2
20/34
28/34
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE9.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB5.Rmd',rmarkdown::pdf_document())
log(1.1)
exp(0.095)
sqrt(2.5)
log(2.5)/2
log(1.58)
log(1.581)
0.65^(1/365)
?sptransform
?spTransform
# lb = .45 and ub is 0.75
lb= .45
ub=0.75
ub-lb
0.45+0.15
0.15/2
curve(dnorm(x,0.6,0.075),0,1)
0.75^3
1-0.421875
0.9^30
4.28/4
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
r <- 0.1     #Assign the value of 0.1 to the object "r", or per-capita growth rate (discrete)
lambda <- 1+r  # define lambda
N0 <- 100    #Assign the value of 100 to the object "N0", or initial population size
nyears <- 30 #Assign the value of 30 to the object "nyears", or the number of time steps to simulate
N0 * lambda   #Multiplies the value stored in the object "N0" by lambda. As soon as you run this line of code, the result of the calculation is printed.
years <- seq(from=0, to=nyears, by=1)   #Creates a sequence of numbers from 0 to the value stored in the object "nyears" (in this case, 50). Because you've told this sequence to increment by 1, you've created a string of numbers from 0 - 50 that contains 51 elements. A single series of elements (e.g., a single column of numbers) is called a vector. You then assign this vector to the object "years".
years                                   #Print the value of the object "years" that you just created.
N <- numeric(nyears+1)    #Make an empty storage vector. The numeric() function takes the contents within the parentheses and converts those contents to the "numeric" class. Don't worry if this doesn't make sense -- what you need to know is that the value within the parentheses (in this case, 50+1=51) is used to tell this function how many zeros to create. So, this line of code creates a vector of 51 zeros, and assigns that vector to the object "N".
N                         #Prints the contents of the object "N".
N[1] <- N0                # The brackets [] are used to indicate the position of an element within a vector. This line of code assigns the value of the object "N0" (100) to the first element in the "N" object. Remember, the "N" object is a vector of 51 zeros. Now, the first zero is changed to 100.
lambda <- 1 + r           # (1 + r) is equal to lambda, the finite rate of growth.  This stores the result of the calculation (1 + 0.1 = 1.1) in the object "lambda".
for (i in 2:(nyears+1)){  # This for-loop will run through the line of code between the curly brackets {}. "i" is simply the name of a variable (you can use "j", or "k", instead -- any variable name will do). "i" changes each time the loop iterates; basically, it will increase by 1 each time the loop is run, starting at "2" up until the specified maximum number of loops "50+1".
N[i] <- lambda*N[i-1]   # This takes the [i - 1] element of "N", multiplies that element by the value of lambda, then assigns that calculated result to the [i] element of "N".
}                         # This ends the for-loop.
N                         # Now print the contents of the object "N".
plot(N~years)   #This plot() function tells R to plot the y variable by the x variable. "N" is the y variable (dependent variable), and "years" is the x variable (independent variable). The tilda "~" stands for "as a function of". There are many ways to customize the appearance of a plot in R - for now, just use the defaults.
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
library(party)
?cforest
?cforest
cforest_unbiased()
rmarkdown::render('LAB1.Rmd',rmarkdown::pdf_document())
