## original grid() function
grid=compiler::cmpfun(function(fun,xlim,ylim,parms,ngrid,maxtime=50,Tlen=500,add=F,color="blue") {
if (add==F) {
plot(1,xlim=xlim, ylim=ylim, type='n',xlab="x",ylab="y");
}
xvals=seq(xlim[1],xlim[2],length=ngrid);
yvals=seq(ylim[1],ylim[2],length=ngrid);
for(i in 1:ngrid) {
for(j in 1:ngrid) {
out=ode(times=seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
out=ode(times=-seq(0,maxtime,length=Tlen),y=c(xvals[i],yvals[j]),func=as.ode.func(fun),parms=parms);
points(out[,2],out[,3],type="l",lwd=2,col=color);
}}
})
# Newton's method to find equilibria of vector field.
# func() must have the same input arguments and returns as for ode/rk4.
# Inputs:
#   x0 = intial guess at equilibrium. If x0 is not supplied in the call,
#        the user chooses it from the current graphics device via locator()
#         and the equilibrium is plotted to the same device. Plotting
#         symbol is closed/open=stable/unstable, circle/triangle=eigenvalues imaginary/real.
#   tol= Convergence tolerance
#   niter = Maximum number of iterations
#   inc = finite-difference increment for derivative estimates
# Coded 5/25/06 by SPE based on Matlab toggle.m by JG
# MODIFIED 7/2016 by PJH to take functions fun(x,y,parms)
newton=compiler::cmpfun(function(fun,x0=NULL,parms=NULL,tol=1e-16,niter=40,inc=1e-6,plotit=TRUE) {
x=x0; #initial x
if (is.null(x0)) {
warning("Oops! newton() was called without x0 specified!");#{x = locator(n=1); x=c(x$x,x$y)};
return(list(x=c(NA,NA,df=matrix(NA,2,2),pch=NA)))
}
nx = length(x); # length of state vector
######### Newton iteration loop: start
for(i in 1:niter){
y = as.ode.func(fun)(0,x,parms)[[1]]
df = matrix(0,nx,nx); # Compute df
for(j in 1:nx) {
#Increment vector for estimating derivative wrt jth coordinate
v=rep(0,nx);
v[j] = inc;
df[,j]=  (as.ode.func(fun)(t,x+v,parms)[[1]] - as.ode.func(fun)(t,x-v,parms)[[1]])/(2*inc)
}
if (sum(y^2) < tol){  #check for convergence
if(plotit){
ev=eigen(df)$values; pch1=1+as.numeric(Im(ev[1])!=0); pch2=1+as.numeric(max(Re(ev))<0);
pchs=matrix( c(2,17,1,16),2,2,byrow=T);
#points(x[1],x[2],type="p",pch=pchs[pch1,pch2],cex=1.5)
}
cat("Fixed point (x,y) = ",x,"\n");
cat("Jacobian Df=","\n"); print(df);cat("Eigenvalues","\n"); print(eigen(df)$values)
return(list(x=x,df=df,pch=pchs[pch1,pch2]))
} # end convergence check
x = x - solve(df,y) # one more step if needed
cat(i, x, "\n") #print out the next iterate
}
######### Newton iteration loop: end
cat("Convergence failed");
})
## to draw fixed points
fixed.points.draw <- compiler::cmpfun(function(FPs) {
for(i in 1:length(FPs)) { points(FPs[[i]]$x[1], FPs[[i]]$x[2], cex=1.5, type="p",pch=FPs[[i]]$pch)}
})
manifolds.calc <- compiler::cmpfun(function(fun,parms,FPs,maxtime=250, Tlen=500) {
ms = list()
for(i in 1:length(FPs)) { if(!any(is.na(FPs[[i]]$x))) {
x=FPs[[i]]$x; df=FPs[[i]]$df; V=eigen(df)$vectors; ev=eigen(df)$values;
if (sign(Re(ev[1])) != -sign(Re(ev[2])) | Im(ev[1]) != 0) {
# if not a saddle...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}else{
i1=which(Re(ev)>0); i2=which(Re(ev)<0);
v1=V[,i1]; v2=V[,i2]; eps=1e-3;
out1=ode(y=x+eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out2=ode(y=x-eps*v1,times=seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out3=ode(y=x+eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
out4=ode(y=x-eps*v2,times=-seq(0,maxtime,length=Tlen),func=as.ode.func(fun),parms=parms);
S = rbind(out3,out4[1,]*NA,out4)[,-1]
U = rbind(out1,out2[1,]*NA,out2)[,-1]
ms[[i]] <- list(S=S,U=U)
}} else { # if x[1] is NA...
ms[[i]] <- list(S=matrix(NA,nrow=1,ncol=2),U=matrix(NA,nrow=1,ncol=2))
}
}
return(ms)
})
manifolds.draw=compiler::cmpfun(function(ms) {
for(i in 1:length(ms)){
S=ms[[i]]$S
U=ms[[i]]$U
title(sub="Black=stable manifold, Red=unstable manifold");
points(S[,1],S[,2],type="l",lwd=2,col="black");
points(U[,1],U[,2],type="l",lwd=2,col="red");
}
})
# Compute Jacobian of a planar vector field at a point (x,y),
# either input or chosen with locator().
jacobianAtXY <- compiler::cmpfun(function(fun,x=NULL, y=NULL,inc=1e-7){
if (is.null(x)|is.null(y)) {
x0 <- locator(n=1); x <- x0$x; y <- x0$y;
}
foo <- fun(x,y); h = inc;
foox <- fun(x+h,y); fooy <- fun(x,y+h);
A <- (foox[1] - foo[1])/h;
B <- (fooy[1] - foo[1])/h;
C <- (foox[2] - foo[2])/h;
D <- (fooy[2] - foo[2])/h;
return(matrix( c(A,B,C,D ),2,2,byrow=T))
})
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]-parms[2]*u*v, parms[3]*u*v-parms[4]*v )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Alpha <- 0.005
Beta <- 0.005
r <- 0.2
q <- 0.1
parms=c(r,Alpha,Beta,q)
# toggle(100,100,parms)
xlim = c(5,200)
ylim = c(5,200)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
#
## END MODEL SPECIFICATION AND INITIALIZATION
#######################################################################################
## SPECIFY MODEL AND INITIALIZE
#
## toggle switch function for phase arrow and nullcline plotting
toggle = compiler::cmpfun(function(u,v,parms) {
c( u*parms[1]-parms[2]*u*v - parms[3]*u^2, parms[4]*u*v-parms[5]*v )
})
fun=toggle ## Our generic name for the system of equations to look at! ;-)
#
## toggle switch function for computing solution trajectories with deSolve::ode()
#Toggle = as.ode.func(toggle)
#
## parameter values?
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
parms=c(r,Alpha,c,Beta,q)
# toggle(100,100,parms)
xlim = c(5,200)
ylim = c(5,200)
new <- phasearrows.calc(toggle,xlim,ylim,resol=25,parms=parms)
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
#
## END MODEL SPECIFICATION AND INITIALIZATION
#######################################################################################
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
## Params
Alpha <- 0.001
Beta <- 0.005
r <- 0.2
q <- 0.1
c <- 0.008
InitPrey <- 100
InitPred <- 75
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step - c*prevyear[1]^2*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
##### LOTKA VOLTERRA PREDATION EXAMPLE
## Params
InitN1 <- 100
InitN2 <- 200
System1 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System1[1+i,] <- doYear(System1[i,])
}
InitN1 <- 100
InitN2 <- 100
System2 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System2[1+i,] <- doYear(System2[i,])
}
InitN1 <- 50
InitN2 <- 20
System3 <- data.frame(n1 = rep(InitN1,(Nyears*10+1)),n2 = InitN2)
## Do simulation
for(i in 1:(Nyears*10+1)){
System3[1+i,] <- doYear(System3[i,])
}
plot(1,1,pch="",xlim=xlim,ylim=ylim,xlab="Prey",ylab="Predators")
phasearrows.draw(new)
abline((r/Alpha),-(c/Alpha),col="red",lwd=3)   # prey
abline(v=q/Beta,col="blue",lwd=3)   # pred
points(jitter(System[,1],500),jitter(System[,2],500),col="brown",pch=20,cex=0.3)
points(jitter(System1[,1],500),jitter(System1[,2],500),col="green",pch=20,cex=0.3)
points(jitter(System2[,1],500),jitter(System2[,2],500),col="red",pch=20,cex=0.3)
points(jitter(System3[,1],500),jitter(System3[,2],500),col="blue",pch=20,cex=0.3)
plot(seq(1,100,length=nrow(System)), System[,1], xlab="Time", ylab="Abundance",type="l",col="orange",lwd=2,ylim=c(0,160),xlim=c(0,95))
points(seq(1,100,length=nrow(System)), System[,2], xlab="Time", ylab="Abundance",type="l",col="green",lwd=2,lty=2)
legend("top",lwd=c(2,2),lty=c(1,2),col=c("orange","green"),legend=c("prey","predator"),bty="n")
TypeIfuncresp <- function(V,alpha){
alpha*V
}
curve(TypeIfuncresp(x,0.1),0,500,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE17.Rmd")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator",col="red",lwd=3)
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,200,xlab="Victim abundance",ylab="Total prey eaten per predator per day",col="red",lwd=3)
# simple functional response
LVfuncresp <- function(V,alpha){
alpha*V
}
curve(LVfuncresp(x,0.03),0,1000,xlab="Victim abundance",ylab="Total prey eaten per predator per day",col="red",lwd=3)
# Numerical response
LVnumresp <- function(V,beta){
beta*V
}
curve(LVnumresp(x,0.001),0,200,xlab="Victim abundance",ylab="Increase in r for predator population",col="blue",lwd=3)
# Numerical response
LVnumresp <- function(V,beta){
beta*V
}
curve(LVnumresp(x,0.001),0,1000,xlab="Victim abundance",ylab="Increase in r for predator population",col="blue",lwd=3)
# LOTKA VOLTERRA PREDATION EXAMPLE (on phase plane)
## Params
Alpha <- 0.001
Beta <- 0.001
InitPrey <- 100
InitPred <- 75
r <- 0.1
q <- 0.1
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
plot(1,1,pch="",ylim=c(0,200),xlim=c(0,200),xlab="prey",ylab="predators")
points(System[seq(1,1000,10),],col="green",type="p",pch=20,cex=0.85)
points(System[1,],col="blue",pch=20,cex=3)
# LOTKA VOLTERRA PREDATION EXAMPLE
## Params
Alpha <- 0.005
Beta <- 0.005
InitPrey <- 100
InitPred <- 75
r <- 0.2
q <- 0.1
Nyears <- 100
step <- 0.1
System <- data.frame(prey = rep(InitPrey,(Nyears+1)*10),pred = InitPred)
doYear <- function(prevyear){
n1 <- prevyear[1] + r*prevyear[1]*step - Alpha*prevyear[1]*prevyear[2]*step
n2 <- prevyear[2] + Beta*prevyear[1]*prevyear[2]*step - q*prevyear[2]*step
return(c(n1,n2))
}
## Do simulation
for(i in 1:(Nyears*10+1)){
System[1+i,] <- doYear(System[i,])
}
plot(1,1,pch="",ylim=c(0,200),xlim=c(0,200),xlab="prey",ylab="predators")
points(System[seq(1,1000,10),],col="green",type="p",pch=20,cex=0.85)
points(System[1,],col="blue",pch=20,cex=3)
unlink("LECTURE17_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LAB7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('index.Rmd',rmarkdown::pdf_document())
rmarkdown::render('schedule.Rmd',rmarkdown::pdf_document())
rmarkdown::render('INTRO.Rmd',rmarkdown::pdf_document())
rmarkdown::render('FINAL_PROJECTS.Rmd',rmarkdown::pdf_document())
#rmarkdown::render('EXTRA_CREDIT.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render('LECTURE3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE5.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE6.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE7.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE8.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE9.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE10.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE11.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE12.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE13.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE14.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE15.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE15.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE16.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE16.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE17.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE17.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE18.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE17.Rmd")
rmd2rscript("LECTURE17.Rmd")
rmd2rscript("LAB1.Rmd")  ##
rmd2rscript("LAB4.Rmd")  ##
rmd2rscript("LAB4.Rmd")  ##
rmd2rscript("LAB5.Rmd")
rmd2rscript("LAB7.Rmd")
rmd2rscript("LECTURE12.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE10.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE10.Rmd")
rmd2rscript("PVA1_421.Rmd")
rmd2rscript("PVA3_421.Rmd")
rmd2rscript_labanswers("LAB1.Rmd")
rmd2rscript_labanswers("LAB1.Rmd")
rmd2rscript_labanswers("LAB2.Rmd")
rmd2rscript_labanswers("LAB2.Rmd")
rmd2rscript_labanswers("LAB3.Rmd")
rmd2rscript_labanswers("LAB4.Rmd")
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
22/300
1-22/300
