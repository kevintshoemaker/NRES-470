rmarkdown::render('LECTURE15.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE15.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE16.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE16.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE17.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE17.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE18.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmarkdown::render('PVA1_421.Rmd',rmarkdown::pdf_document())
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE8.Rmd")
rmd2rscript("LECTURE15.Rmd")
rmd2rscript("LECTURE16.Rmd")
rmd2rscript("LECTURE17.Rmd")
rmd2rscript("LECTURE17.Rmd")
rmd2rscript("LAB1.Rmd")  ##
rmd2rscript("LAB4.Rmd")  ##
rmd2rscript("LAB4.Rmd")  ##
rmd2rscript("LAB5.Rmd")
rmd2rscript("LAB7.Rmd")
rmd2rscript("LECTURE12.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE10.Rmd")
rmd2rscript("LECTURE9.Rmd")
rmd2rscript("LECTURE10.Rmd")
rmd2rscript("PVA1_421.Rmd")
rmd2rscript("PVA3_421.Rmd")
rmd2rscript_labanswers("LAB1.Rmd")
rmd2rscript_labanswers("LAB1.Rmd")
rmd2rscript_labanswers("LAB2.Rmd")
rmd2rscript_labanswers("LAB2.Rmd")
rmd2rscript_labanswers("LAB3.Rmd")
rmd2rscript_labanswers("LAB4.Rmd")
rmd2rscript("LECTURE7.Rmd")  ##
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
22/300
1-22/300
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('index.Rmd', 'word_document')
rmarkdown::render('schedule.Rmd', 'word_document')
unlink("LECTURE2_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#rmarkdown::render('EXTRA_CREDIT.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE1.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE2.Rmd',rmarkdown::pdf_document())  # latex_engine="xelatex"
rmarkdown::render('LECTURE3.Rmd',rmarkdown::pdf_document())
rmarkdown::render('LECTURE4.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,15000,10)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 0.9   # maximum reproduction (at low densities)
d_min <- 0.2  # minimum mortality (at low densities)
a <- 0.00009    # D-D terms
c <- 0.00006
b <- b_max - a*Density
d <- d_min + c*Density
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,15000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
360/12
Density <- seq(0,15000,10)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 1   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00001    # D-D terms
c <- 0.00003
b <- b_max - a*Density
d <- d_min + c*Density
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,15000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
Density <- seq(0,100000,100)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 1   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00001    # D-D terms
c <- 0.00003
b <- b_max - a*Density
d <- d_min + c*Density
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,15000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
Density <- seq(0,100000,100)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 1   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00001    # D-D terms
c <- 0.00003
b <- b_max - a*Density
d <- d_min + c*Density
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,100000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
options(scipen=100)
Density <- seq(0,100000,100)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 1   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00001    # D-D terms
c <- 0.00003
b <- b_max - a*Density
d <- d_min + c*Density
options(scipen=100)
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,100000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
Density <- seq(0,100000,100)  # create a sequence of numbers from 0 to 15000, representing a range of population densities
## CONSTANTS
b_max <- 1   # maximum reproduction (at low densities)
d_min <- 0.25  # minimum mortality (at low densities)
a <- 0.00001    # D-D terms
c <- 0.00003
b <- b_max - a*Density
d <- d_min + c*Density
options(scipen=100)
K <- (b_max-d_min)/(a+c)   # compute carrying capacity
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,2),main="Density-Dependence!",xlim=c(0,50000),ylab="Vital rate (b or d)")
points(Density,d,type="l",col="red",lwd=2)
legend("topleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB2.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
Density <- seq(0,500,1)  # create a sequence of numbers from 0 to 500, representing a range of population densities
## CONSTANTS
b_max <- 0.8  # maximum reproduction (at low densities)
d_min <- 0.3  # minimum mortality
a <- 0.001    # D-D terms
c <- 0.0005
b <- b_max - a*Density
d <- d_min + c*Density
plot(Density,b,type="l",col="green",lwd=2,ylim=c(0,1),main="Density-Dependence!",ylab="b or d")
lines(Density,d,col="red",lwd=2)
axis(4,at=seq(0,1,0.2))
#mtext("d",4)
legend("bottomleft",col=c("green","red"),lty=c(1,1),legend=c("per-capita birth rate","per-capita mortality"),bty="n")
log(.1/.9)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
install.packages("mra")
unlink("LAB4_cache", recursive = TRUE)
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#  NRES 470, Lab 4 -------------------------------
#  Kevin Shoemaker
#  University of Nevada, Reno
#  Matrix population models
# First, build a simple projection matrix called TMat
TMat <- matrix(     #
c(
0.25,     1.5,   1.5,
0.4,   0,     0,
0,     0.75,   0
)
,nrow=3,ncol=3,byrow=T
)
TMat    # print to the console to check!
# Then we specify initial abundances for the three age classes
InitAbund <- c(1000,0,0)    # initial abundance vector
InitAbund    # print to the console to check!
# Now we can run the code for real
# project year-1 abundance:
Year1 <- TMat %*% InitAbund  # matrix multiplication in R uses the symbol '%*%'
Year1
# Project year-2 abundance
Year2 <- TMat %*% Year1  # matrix multiplication!
Year2
# Multi-year projection code ----------------------------
#  You may want to modify this code for the examples below:
# Set key parameters -----------------------
nYears <- 20                                            # set the number of years to project
TMat <- matrix(     #
c(
0.25,     1.5,   1.5,
0.4,   0,     0,
0,     0.75,   0
)
,nrow=3,ncol=3,byrow=T
)
InitAbund <- c(1000,0,0)                                # initial abundance vector
AgeStructured <- TRUE          # set to TRUE for Leslie matrix and FALSE for Lefkovitch
# Use a FOR loop for multi-year projection  -------------
# NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all stages and all years!
allYears[,1] <- InitAbund  # set the year 0 abundance
for(t in 2:(nYears+1)){   # loop through all years
allYears[,t] <-  TMat %*% allYears[,t-1]
}
plot(1,1,pch="",ylim=c(0,max(allYears)),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")  # set up blank plot
cols <- rainbow(ncol(TMat))    # set up colors to use
for(s in 1:ncol(TMat)){
points(allYears[s,],col=cols[s],type="l",lwd=2)     # plot out each life stage abundance, one at a time
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))   # label the axis
if(AgeStructured){
leg <-  paste("Age",seq(1,(ncol(TMat))))
}else{
leg <- paste("Stage",seq(1,ncol(TMat)))
}
legend("topleft",col=cols,lwd=rep(2,ncol(TMat)),legend=leg,bty="n")  # put a legend on the plot
# Use 'popbio' package to compute lambda and SSD -----------
# Use the following line of code if you haven't installed 'popbio' yet. Once you've installed it, you can delete the line or comment this line out by adding a pound sign before the "i" in "install.packages"
# install.packages("popbio")   # uncomment this line to run - you only need to do this once
# Use the 'popbio' package to compute lambda (NOTE: you first have to install the popbio package! You only have to install the package once...)
library(popbio)   # load the 'popbio' package in R
lambda(TMat)
# Use the 'popbio' package to compute the stable stage distribution!
stable.stage(TMat)
lifetable <- read.csv("life_table4.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#  NRES 470, Lab 4 -------------------------------
#  Kevin Shoemaker
#  University of Nevada, Reno
#  Matrix population models
# First, build a simple projection matrix called TMat
TMat <- matrix(     #
c(
0.25,     1.5,   1.5,
0.4,   0,     0,
0,     0.75,   0
)
,nrow=3,ncol=3,byrow=T
)
TMat    # print to the console to check!
# Then we specify initial abundances for the three age classes
InitAbund <- c(1000,0,0)    # initial abundance vector
InitAbund    # print to the console to check!
# Now we can run the code for real
# project year-1 abundance:
Year1 <- TMat %*% InitAbund  # matrix multiplication in R uses the symbol '%*%'
Year1
# Project year-2 abundance
Year2 <- TMat %*% Year1  # matrix multiplication!
Year2
# Multi-year projection code ----------------------------
#  You may want to modify this code for the examples below:
# Set key parameters -----------------------
nYears <- 20                                            # set the number of years to project
TMat <- matrix(     #
c(
0.25,     1.5,   1.5,
0.4,   0,     0,
0,     0.75,   0
)
,nrow=3,ncol=3,byrow=T
)
InitAbund <- c(1000,0,0)                                # initial abundance vector
AgeStructured <- TRUE          # set to TRUE for Leslie matrix and FALSE for Lefkovitch
# Use a FOR loop for multi-year projection  -------------
# NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all stages and all years!
allYears[,1] <- InitAbund  # set the year 0 abundance
for(t in 2:(nYears+1)){   # loop through all years
allYears[,t] <-  TMat %*% allYears[,t-1]
}
plot(1,1,pch="",ylim=c(0,max(allYears)),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")  # set up blank plot
cols <- rainbow(ncol(TMat))    # set up colors to use
for(s in 1:ncol(TMat)){
points(allYears[s,],col=cols[s],type="l",lwd=2)     # plot out each life stage abundance, one at a time
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))   # label the axis
if(AgeStructured){
leg <-  paste("Age",seq(1,(ncol(TMat))))
}else{
leg <- paste("Stage",seq(1,ncol(TMat)))
}
legend("topleft",col=cols,lwd=rep(2,ncol(TMat)),legend=leg,bty="n")  # put a legend on the plot
# Use 'popbio' package to compute lambda and SSD -----------
# Use the following line of code if you haven't installed 'popbio' yet. Once you've installed it, you can delete the line or comment this line out by adding a pound sign before the "i" in "install.packages"
# install.packages("popbio")   # uncomment this line to run - you only need to do this once
# Use the 'popbio' package to compute lambda (NOTE: you first have to install the popbio package! You only have to install the package once...)
library(popbio)   # load the 'popbio' package in R
lambda(TMat)
# Use the 'popbio' package to compute the stable stage distribution!
stable.stage(TMat)
lifetable <- read.csv("life_table4.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
lifetable <- read.csv("life_table4.csv")
lifetable
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
#  NRES 470, Lab 4 -------------------------------
#  Kevin Shoemaker
#  University of Nevada, Reno
#  Matrix population models
# First, build a simple projection matrix called TMat
TMat <- matrix(     #
c(
0.25,     1.5,   1.5,
0.4,   0,     0,
0,     0.75,   0
)
,nrow=3,ncol=3,byrow=T
)
TMat    # print to the console to check!
# Then we specify initial abundances for the three age classes
InitAbund <- c(1000,0,0)    # initial abundance vector
InitAbund    # print to the console to check!
# Now we can run the code for real
# project year-1 abundance:
Year1 <- TMat %*% InitAbund  # matrix multiplication in R uses the symbol '%*%'
Year1
# Project year-2 abundance
Year2 <- TMat %*% Year1  # matrix multiplication!
Year2
# Multi-year projection code ----------------------------
#  You may want to modify this code for the examples below:
# Set key parameters -----------------------
nYears <- 20                                            # set the number of years to project
TMat <- matrix(     #
c(
0.25,     1.5,   1.5,
0.4,   0,     0,
0,     0.75,   0
)
,nrow=3,ncol=3,byrow=T
)
InitAbund <- c(1000,0,0)                                # initial abundance vector
AgeStructured <- TRUE          # set to TRUE for Leslie matrix and FALSE for Lefkovitch
# Use a FOR loop for multi-year projection  -------------
# NOTE: the code below can be re-used without modification:
allYears <- matrix(0,nrow=nrow(TMat),ncol=nYears+1)     # build a storage array for all stages and all years!
allYears[,1] <- InitAbund  # set the year 0 abundance
for(t in 2:(nYears+1)){   # loop through all years
allYears[,t] <-  TMat %*% allYears[,t-1]
}
plot(1,1,pch="",ylim=c(0,max(allYears)),xlim=c(0,nYears+1),xlab="Years",ylab="Abundance",xaxt="n")  # set up blank plot
cols <- rainbow(ncol(TMat))    # set up colors to use
for(s in 1:ncol(TMat)){
points(allYears[s,],col=cols[s],type="l",lwd=2)     # plot out each life stage abundance, one at a time
}
axis(1,at=seq(1,nYears+1),labels = seq(0,nYears))   # label the axis
if(AgeStructured){
leg <-  paste("Age",seq(1,(ncol(TMat))))
}else{
leg <- paste("Stage",seq(1,ncol(TMat)))
}
legend("topleft",col=cols,lwd=rep(2,ncol(TMat)),legend=leg,bty="n")  # put a legend on the plot
# Use 'popbio' package to compute lambda and SSD -----------
# Use the following line of code if you haven't installed 'popbio' yet. Once you've installed it, you can delete the line or comment this line out by adding a pound sign before the "i" in "install.packages"
# install.packages("popbio")   # uncomment this line to run - you only need to do this once
# Use the 'popbio' package to compute lambda (NOTE: you first have to install the popbio package! You only have to install the package once...)
library(popbio)   # load the 'popbio' package in R
lambda(TMat)
# Use the 'popbio' package to compute the stable stage distribution!
stable.stage(TMat)
lifetable <- read.csv("life_table4.csv")
knitr::kable(lifetable,caption="",col.names = c("x","S(x)","b(x)"))
#lifetable
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
unlink("LAB4_cache", recursive = TRUE)
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
unlink("LAB4_cache", recursive = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
rmd2rscript <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- "echo"
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- !grepl(input, pattern = stringToFind2, perl = TRUE)   # is it hidden (echo=FALSE)
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmd2rscript_labanswers <- function(infile="LECTURE2.Rmd"){    # function for converting markdown to scripts
outfile <- gsub(".Rmd",".R",infile)
close( file( outfile, open="w" ) )   # clear output file
con1 <- file(infile,open="r")
con2 <- file(outfile,"w")
stringToFind <- "```{r*"
stringToFind2 <- c("answer","test")
isrblock <- FALSE
#count=0
blocknum=0
while(length(input <- readLines(con1, n=1)) > 0){   # while there are still lines to be read
isrblock <- grepl(input, pattern = stringToFind, perl = TRUE)   # is it the start of an R block?
showit <- grepl(input, pattern = stringToFind2[1], perl = TRUE) | grepl(input, pattern = stringToFind2[2])
if(isrblock){
blocknum=blocknum+1
while(!grepl(newline<-readLines(con1, n=1),pattern="```",perl=TRUE)){
if((blocknum>1)&((showit)|(blocknum==2))) write(newline,file=con2,append=TRUE)
#count=count+1
}
isrblock=FALSE
}
}
closeAllConnections()
}
rmarkdown::render('LAB4.Rmd',rmarkdown::pdf_document())
rmd2rscript("LAB4.Rmd")  ##
c=1000
A=1:10
(c/2)*A^2
